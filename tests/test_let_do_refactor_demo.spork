;; Comprehensive test demonstrating the benefits of the refactored let/do implementation
;; This shows that the simplified compiler now handles complex cases correctly

(print "=== Refactored Let/Do Implementation Demo ===\n")

;; Test 1: set! in do expression (no scope issues!)
(def test-set-in-do
  (fn []
    (let [x 5
          y 10]
      (if (< x y)
        (do
          (set! x (* x 2))
          (set! y (+ y 5))
          (+ x y))
        0))))

(print "Test 1 - set! in do expression:")
(print "  Result:" (test-set-in-do))
(print "  Expected: 25 (x=10, y=15)")

;; Test 2: Nested lets with shared variable access
(def test-nested-let-closures
  (fn []
    (let [base 10]
      (let [multiplier 3
            compute (fn [x] (* x multiplier base))]
        (compute 2)))))

(print "\nTest 2 - Nested lets with closures:")
(print "  Result:" (test-nested-let-closures))
(print "  Expected: 60 (2 * 3 * 10)")

;; Test 3: do with multiple set! operations
(def test-multiple-sets
  (fn []
    (let [a 1
          b 2
          c 3]
      (do
        (set! a (* a 10))
        (set! b (* b 20))
        (set! c (* c 30))
        (+ a b c)))))

(print "\nTest 3 - Multiple set! in do:")
(print "  Result:" (test-multiple-sets))
(print "  Expected: 140 (10 + 40 + 90)")

;; Test 4: Complex control flow with set!
(def test-complex-control-flow
  (fn []
    (let [result 0
          i 0]
      (while (< i 5)
        (do
          (set! result (+ result i))
          (set! i (+ i 1))))
      result)))

(print "\nTest 4 - while loop with set! in do:")
(print "  Result:" (test-complex-control-flow))
(print "  Expected: 10 (0+1+2+3+4)")

;; Test 5: Method calls in let expressions
(def test-method-calls-in-let
  (fn []
    (let [data (list)
          text "hello world"]
      (.append data 1)
      (.append data 2)
      (.append data 3)
      (let [upper (.upper text)
            count (len data)]
        [upper count]))))

(print "\nTest 5 - Method calls with .method syntax:")
(print "  Result:" (test-method-calls-in-let))
(print "  Expected: [\"HELLO WORLD\" 3]")

;; Test 6: Deeply nested lets with shared variables
(def test-deep-nesting
  (fn []
    (let [x 1]
      (let [y 2]
        (let [z 3]
          (let [sum (+ x y z)
                product (* x y z)]
            (do
              (set! sum (* sum 2))
              [sum product])))))))

(print "\nTest 6 - Deeply nested lets:")
(print "  Result:" (test-deep-nesting))
(print "  Expected: [12 6]")

;; Test 7: let with try/catch and set!
(def test-try-catch-with-set
  (fn []
    (let [status "unknown"
          result 0]
      (try
        (do
          (set! status "trying")
          (set! result (/ 42 2))
          (set! status "success"))
        (catch Exception e
          (set! status "error")))
      [status result])))

(print "\nTest 7 - try/catch with set! in do:")
(print "  Result:" (test-try-catch-with-set))
(print "  Expected: [\"success\" 21.0]")

;; Test 8: Uniform semantics - all lets use same compilation strategy
(def test-uniform-semantics
  (fn []
    (let [a (let [x 10] x)
          b (let [y 20] y)
          c (let [z 30] z)]
      (+ a b c))))

(print "\nTest 8 - Uniform let semantics:")
(print "  Result:" (test-uniform-semantics))
(print "  Expected: 60")

;; Test 9: Statement-friendly features work everywhere
(def test-statement-friendly
  (fn []
    (let [result (list)]
      (for [i [1 2 3]]
        (.append result (* i 2)))
      (let [total 0]
        (for [x result]
          (set! total (+ total x)))
        total))))

(print "\nTest 9 - Statement-friendly bodies:")
(print "  Result:" (test-statement-friendly))
(print "  Expected: 12 (2+4+6)")

;; Test 10: Complex real-world example
(def test-real-world-example
  (fn []
    (let [numbers [1 2 3 4 5 6 7 8 9 10]
          evens (list)
          sum 0]
      ;; Filter evens using for loop and method call
      (for [n numbers]
        (if (= (% n 2) 0)
          (.append evens n)
          nil))
      ;; Sum using while loop with set!
      (let [i 0]
        (while (< i (len evens))
          (do
            (set! sum (+ sum (get evens i)))
            (set! i (+ i 1)))))
      [evens sum])))

(print "\nTest 10 - Real-world example:")
(print "  Result:" (test-real-world-example))
(print "  Expected: [[2 4 6 8 10] 30]")

(print "\n=== Summary ===")
(print "✓ Simplified compiler logic - always use wrapper functions")
(print "✓ Uniform semantics - no special cases")
(print "✓ Statement-friendly - while, for, try, set! all work")
(print "✓ Proper closures - nested lets can access outer variables")
(print "✓ No scope issues - do doesn't create new scope")
(print "✓ Method calls - .method syntax works everywhere")
(print "\nAll tests demonstrate the benefits of the refactored approach!")
