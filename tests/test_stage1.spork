; Test file for Stage 1: Minimal "real language core"
; Tests: let, fn, while, for, return, set!

(ns test-stage1
  (:import [builtins :refer [range]]
           [types :refer [SimpleNamespace]]))

(print "=== Testing let (statement context) ===")

(defn test-let-stmt []
  (let [x 10
        y 20]
    (print "x =" x)
    (print "y =" y)
    (print "x + y =" (+ x y))))

(test-let-stmt)

; Sequential bindings
(defn test-sequential-bindings []
  (let [a 5
        b (+ a 3)
        c (* b 2)]
    (print "a =" a "b =" b "c =" c)))

(test-sequential-bindings)

(print "\n=== Testing let (expression context) ===")

(def result1 (let [x 100
                   y 200]
               (+ x y)))

(print "let expr result:" result1)

; Nested let
(def result2 (let [a 1]
               (let [b 2]
                 (+ a b))))

(print "nested let result:" result2)

; Let with sequential binding in expression context
(def result3 (let [x 10
                   y (+ x 5)
                   z (* y 2)]
               z))

(print "sequential let expr:" result3)

(print "\n=== Testing fn literals ===")

; Simple lambda
(def add (fn [x y] (+ x y)))
(print "add 3 4 =" (add 3 4))

; Lambda with no args
(def get-42 (fn [] 42))
(print "get-42 =" (get-42))

; Lambda with multiple body forms
(def verbose-add (fn [x y]
                   (print "Adding" x "and" y)
                   (+ x y)))

(print "verbose-add result:" (verbose-add 10 20))

; Higher-order function
(def apply-twice (fn [f x]
                   (f (f x))))

(def inc (fn [n] (+ n 1)))
(print "apply-twice inc 5 =" (apply-twice inc 5))

; Closure
(def make-adder (fn [n]
                  (fn [x] (+ x n))))

(def add10 (make-adder 10))
(print "add10 5 =" (add10 5))

(print "\n=== Testing while loops ===")

(defn test-while []
  (let [i 0]
    (while (< i 5)
      (print "i =" i)
      (set! i (+ i 1)))))

(test-while)

; While with multiple statements
(defn count-down [n]
  (while (> n 0)
    (print "Countdown:" n)
    (set! n (- n 1)))
  (print "Blastoff!")
  nil)

(count-down 3)

(print "\n=== Testing for loops ===")

(for [x [1 2 3 4 5]]
  (print "x =" x))

; For with range
(for [i (range 3)]
  (print "i =" i))

; For with multiple statements
(for [item ["apple" "banana" "cherry"]]
  (print "Processing:" item)
  (print "Length:" (len item)))

(print "\n=== Testing return ===")

(defn early-return [x]
  (if (< x 0)
    (return "negative")
    nil)
  (if (> x 100)
    (return "too large")
    nil)
  "just right")

(print "early-return -5:" (early-return -5))
(print "early-return 200:" (early-return 200))
(print "early-return 50:" (early-return 50))

; Return with no value
(defn print-and-return [msg]
  (print msg)
  (return))

(print "return value:" (print-and-return "Hello!"))

(print "\n=== Testing set! ===")

; Simple variable mutation
(def counter 0)
(print "counter initial:" counter)
(set! counter 10)
(print "counter after set!:" counter)
(set! counter (+ counter 5))
(print "counter after increment:" counter)

; Mutation in loops
(defn sum-range [n]
  (let [total 0
        i 0]
    (while (< i n)
      (set! total (+ total i))
      (set! i (+ i 1)))
    (return total)))

(print "sum-range 10 =" (sum-range 10))

; Attribute mutation
(def obj (SimpleNamespace))
(set! (. obj x) 100)
(set! (. obj y) 200)
(print "obj.x =" (. obj x))
(print "obj.y =" (. obj y))

(print "\n=== Testing combinations ===")

; For + let + fn
(defn process-list [items]
  (for [item items]
    (let [result ((fn [x] (* x x)) item)]
      (print "Square of" item "is" result))))

(process-list [1 2 3 4 5])

; While + return
(defn find-first [pred lst]
  (let [i 0
        n (len lst)]
    (while (< i n)
      (let [item ((. lst __getitem__) i)]
        (if (pred item)
          (return item)
          nil))
      (set! i (+ i 1)))
    (return nil)))

(def is-even (fn [x] (= (% x 2) 0)))
(print "First even in [1 3 5 6 7 8]:" (find-first is-even [1 3 5 6 7 8]))

; Nested let with fn
(def result4 (let [x 10]
               (let [f (fn [y] (+ x y))]
                 (let [z (f 20)]
                   z))))

(print "nested let with fn:" result4)

(print "\n=== Testing edge cases ===")

; Empty let
(def empty-let-result (let [] 42))
(print "empty let:" empty-let-result)

; Let with side effects
(def let-side-effects
  (let [x (do (print "Evaluating x") 1)
        y (do (print "Evaluating y") 2)]
    (+ x y)))

(print "let with side effects result:" let-side-effects)

; Fn returning fn
(def make-multiplier (fn [factor]
                       (fn [x] (* x factor))))

(def times3 (make-multiplier 3))
(print "times3 7 =" (times3 7))

; While with break condition via return
(defn search [target lst]
  (let [i 0]
    (while (< i (len lst))
      (if (= ((. lst __getitem__) i) target)
        (return i)
        nil)
      (set! i (+ i 1)))
    (return -1)))

(print "search 30 in [10 20 30 40]:" (search 30 [10 20 30 40]))
(print "search 99 in [10 20 30 40]:" (search 99 [10 20 30 40]))

(print "\n=== All Stage 1 tests complete! ===")
