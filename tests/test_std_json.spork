; Test suite for std.json module
; Tests JSON serialization of Spork's persistent data structures

(ns tests.test-std-json
  (:require [std.json :as json]))

; === Test helpers ===

(defn assert-eq [expected actual msg]
  (if (= expected actual)
    (do
      (print (fmt "âœ“ {}" msg))
      true)
    (do
      (print (fmt "âœ— {} - expected: {} got: {}" msg expected actual))
      false)))

(defn assert-true [val msg]
  (assert-eq true val msg))

(defn assert-contains [s substr msg]
  (if (in substr s)
    (do
      (print (fmt "âœ“ {}" msg))
      true)
    (do
      (print (fmt "âœ— {} - '{}' not found in '{}'" msg substr s))
      false)))

; === Basic Map serialization ===

(defn test-simple-map []
  (print "\n--- Testing simple map serialization ---")
  (let [m {:name "Spork" :version 1}
        result (json.dumps m)]
    [(assert-contains result "\"name\"" "Map key serialized")
     (assert-contains result "\"Spork\"" "Map string value serialized")
     (assert-contains result "\"version\"" "Map key 'version' serialized")
     (assert-contains result "1" "Map integer value serialized")]))

(defn test-nested-map []
  (print "\n--- Testing nested map serialization ---")
  (let [m {:outer {:inner "value"}}
        result (json.dumps m)]
    [(assert-contains result "\"outer\"" "Outer key serialized")
     (assert-contains result "\"inner\"" "Inner key serialized")
     (assert-contains result "\"value\"" "Inner value serialized")]))

; === Vector serialization ===

(defn test-simple-vector []
  (print "\n--- Testing simple vector serialization ---")
  (let [v [1 2 3]
        result (json.dumps v)]
    [(assert-eq "[1, 2, 3]" result "Vector serialized to JSON array")]))

(defn test-nested-vector []
  (print "\n--- Testing nested vector serialization ---")
  (let [v [[1 2] [3 4]]
        result (json.dumps v)]
    [(assert-eq "[[1, 2], [3, 4]]" result "Nested vector serialized")]))

(defn test-mixed-vector []
  (print "\n--- Testing mixed type vector serialization ---")
  (let [v [1 "two" 3.0 true nil]
        result (json.dumps v)]
    [(assert-eq "[1, \"two\", 3.0, true, null]" result "Mixed vector serialized")]))

; === Set serialization ===

(defn test-set-serialization []
  (print "\n--- Testing set serialization ---")
  (let [s #{1 2 3}
        result (json.dumps s)
        ; Sets become arrays but order may vary
        parsed (json.loads result)]
    [(assert-eq 3 (len parsed) "Set serialized as 3-element array")
     (assert-true (in 1 parsed) "Set contains 1")
     (assert-true (in 2 parsed) "Set contains 2")
     (assert-true (in 3 parsed) "Set contains 3")]))

; === Keyword serialization ===

(defn test-keyword-as-value []
  (print "\n--- Testing keyword as value ---")
  (let [m {:status :active}
        result (json.dumps m)]
    [(assert-contains result ":active" "Keyword value includes colon")]))

(defn test-keyword-as-key []
  (print "\n--- Testing keyword as key ---")
  (let [m {:name "test"}
        result (json.dumps m)]
    ; Keywords as keys should NOT have colon (cleaner JSON)
    [(assert-contains result "\"name\"" "Keyword key becomes string without colon")]))

; === Complex nested structures ===

(defn test-complex-structure []
  (print "\n--- Testing complex nested structure ---")
  (let [data {:users [{:name "Alice" :age 30}
                      {:name "Bob" :age 25}]
              :meta {:version 1 :active true}}
        result (json.dumps data)]
    [(assert-contains result "\"users\"" "Top-level key serialized")
     (assert-contains result "\"Alice\"" "Nested user name serialized")
     (assert-contains result "\"Bob\"" "Second user name serialized")
     (assert-contains result "\"meta\"" "Meta key serialized")
     (assert-contains result "\"active\"" "Nested meta key serialized")
     (assert-contains result "true" "Boolean true serialized")]))

; === Pretty printing ===

(defn test-dumps-pretty []
  (print "\n--- Testing pretty printing ---")
  (let [m {:a 1}
        result (json.dumps-pretty m)]
    [(assert-contains result "\n" "Pretty output contains newlines")
     (assert-contains result "  " "Pretty output contains indentation")]))

; === Round-trip (dumps then loads) ===

(defn test-roundtrip []
  (print "\n--- Testing round-trip serialization ---")
  (let [original {"name" "test" "value" 42 "items" [1 2 3]}
        json-str (json.dumps original)
        parsed (json.loads json-str)]
    [(assert-eq (get original "name") (get parsed "name") "String survives round-trip")
     (assert-eq (get original "value") (get parsed "value") "Integer survives round-trip")
     (assert-eq 3 (len (get parsed "items")) "Array length survives round-trip")]))

; === loads returns Spork types ===

(defn test-loads-returns-spork-types []
  (print "\n--- Testing loads returns Spork types ---")
  (let [result (json.loads "{\"x\": 1, \"items\": [1, 2, 3]}")]
    ; Check that we get Spork Map and Vector, not Python dict and list
    [(assert-eq "Map" (. (type result) __name__) "loads returns Spork Map")
     (assert-eq "Vector" (. (type (get result "items")) __name__) "Nested array is Spork Vector")
     (assert-eq 1 (get result "x") "Can access map values")
     (assert-eq 3 (len (get result "items")) "Vector has correct length")]))

(defn test-loads-keywordize-keys []
  (print "\n--- Testing loads with keywordize-keys ---")
  (let [result (json.loads "{\"name\": \"Alice\", \"age\": 30}" true)]
    [(assert-eq "Alice" (get result :name) "Keyword key :name works")
     (assert-eq 30 (get result :age) "Keyword key :age works")]))

; === loads/parse ===

(defn test-loads []
  (print "\n--- Testing JSON parsing ---")
  (let [result (json.loads "{\"x\": 1, \"y\": 2}")]
    [(assert-eq 1 (get result "x") "Parsed x value")
     (assert-eq 2 (get result "y") "Parsed y value")]))

(defn test-parse-alias []
  (print "\n--- Testing parse alias ---")
  (let [result (json.parse "[1, 2, 3]")]
    [(assert-eq 3 (len result) "Parse alias works")]))

; === generate alias ===

(defn test-generate-alias []
  (print "\n--- Testing generate alias ---")
  (let [result (json.generate {:key "value"})]
    [(assert-contains result "\"key\"" "Generate alias works")]))

; === Edge cases ===

(defn test-empty-structures []
  (print "\n--- Testing empty structures ---")
  [(assert-eq "{}" (json.dumps {}) "Empty map")
   (assert-eq "[]" (json.dumps []) "Empty vector")])

(defn test-special-characters []
  (print "\n--- Testing special characters in strings ---")
  (let [m {:text "hello\nworld"}
        result (json.dumps m)]
    [(assert-contains result "\\n" "Newline escaped in JSON")]))

(defn test-unicode []
  (print "\n--- Testing unicode ---")
  (let [m {:emoji "ğŸ‘" :japanese "ã“ã‚“ã«ã¡ã¯"}
        result (json.dumps m)]
    ; With ensure_ascii=True (default), unicode gets escaped
    ; Just verify it serializes without error
    [(assert-true (> (len result) 0) "Unicode map serializes")]))

(defn test-numeric-types []
  (print "\n--- Testing numeric types ---")
  (let [m {:int 42 :float 3.14 :neg -10 :zero 0}
        result (json.dumps m)]
    [(assert-contains result "42" "Integer serialized")
     (assert-contains result "3.14" "Float serialized")
     (assert-contains result "-10" "Negative serialized")
     (assert-contains result "0" "Zero serialized")]))

; === Count results helper ===

(defn count-results [results]
  (reduce (fn [acc r]
            (if r
              (assoc acc :passed (+ 1 (get acc :passed)))
              (assoc acc :failed (+ 1 (get acc :failed)))))
          {:passed 0 :failed 0}
          (flatten results)))

; === Run all tests ===

(defn run-tests []
  (print "=== std.json Test Suite ===")

  (let [results
        (concat
          ; Map tests
          (test-simple-map)
          (test-nested-map)

          ; Vector tests
          (test-simple-vector)
          (test-nested-vector)
          (test-mixed-vector)

          ; Set tests
          (test-set-serialization)

          ; Keyword tests
          (test-keyword-as-value)
          (test-keyword-as-key)

          ; Complex structure tests
          (test-complex-structure)

          ; Pretty printing
          (test-dumps-pretty)

          ; Round-trip
          (test-roundtrip)

          ; Spork type returns
          (test-loads-returns-spork-types)
          (test-loads-keywordize-keys)

          ; Parsing
          (test-loads)
          (test-parse-alias)
          (test-generate-alias)

          ; Edge cases
          (test-empty-structures)
          (test-special-characters)
          (test-unicode)
          (test-numeric-types))

        counts (count-results results)
        passed (get counts :passed)
        failed (get counts :failed)
        total (+ passed failed)]

    ; Summary
    (print (fmt "\n=== Test Summary ===" ))
    (print (fmt "Passed: {}/{}" passed total))
    (if (= failed 0)
      (print "All tests passed!")
      (print (fmt "{} tests failed!" failed)))))

(run-tests)
