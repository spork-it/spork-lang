; Test file for with statement (context managers)

(ns test-with
  (:import [contextlib]
           [os]
           [tempfile]))

(print "=== Testing with Statement (Context Managers) ===\n")

; ============================================================================
; Helper: Create a simple context manager for testing
; ============================================================================

(def test-log (list))

(defn log [msg]
  (.append test-log msg)
  (print msg))

; Use contextlib.contextmanager to create test context managers
(def simple-cm
  ((. contextlib contextmanager)
   (fn ^generator []
     (log "enter")
     (yield "resource")
     (log "exit"))))

; ============================================================================
; 1. Basic with statement - simple binding
; ============================================================================

(print "--- 1. Basic with statement ---")

(set! test-log (list))
(with [r (simple-cm)]
  (log (+ "using: " r)))

(print "Log:" test-log)
(assert (= (vec test-log) ["enter" "using: resource" "exit"]))
(print "✓ Basic with works\n")

; ============================================================================
; 2. With statement without binding
; ============================================================================

(print "--- 2. With without binding ---")

(def no-bind-cm
  ((. contextlib contextmanager)
   (fn ^generator []
     (log "no-bind enter")
     (yield)
     (log "no-bind exit"))))

(set! test-log (list))
(with [(no-bind-cm)]
  (log "inside"))

(print "Log:" test-log)
(assert (= (vec test-log) ["no-bind enter" "inside" "no-bind exit"]))
(print "✓ With without binding works\n")

; ============================================================================
; 3. Multiple context managers
; ============================================================================

(print "--- 3. Multiple context managers ---")

(def cm1
  ((. contextlib contextmanager)
   (fn ^generator []
     (log "cm1 enter")
     (yield "r1")
     (log "cm1 exit"))))

(def cm2
  ((. contextlib contextmanager)
   (fn ^generator []
     (log "cm2 enter")
     (yield "r2")
     (log "cm2 exit"))))

(set! test-log (list))
(with [a (cm1)
       b (cm2)]
  (log (+ "using: " a " and " b)))

(print "Log:" test-log)
; Context managers enter in order, exit in reverse order
(assert (= (vec test-log) ["cm1 enter" "cm2 enter" "using: r1 and r2" "cm2 exit" "cm1 exit"]))
(print "✓ Multiple context managers work\n")

; ============================================================================
; 4. With in function returning value
; ============================================================================

(print "--- 4. With returning value from function ---")

(defn read-resource []
  (with [r (simple-cm)]
    (+ "got: " r)))

(set! test-log (list))
(def result (read-resource))
(print "Result:" result)
(print "Log:" test-log)
(assert (= result "got: resource"))
(assert (= (vec test-log) ["enter" "exit"]))
(print "✓ With in function with return works\n")

; ============================================================================
; 5. Destructuring binding
; ============================================================================

(print "--- 5. Destructuring binding ---")

(def pair-cm
  ((. contextlib contextmanager)
   (fn ^generator []
     (log "pair enter")
     (yield [1 2])
     (log "pair exit"))))

(set! test-log (list))
(with [[a b] (pair-cm)]
  (log (+ "a=" (str a) " b=" (str b))))

(print "Log:" test-log)
(assert (= (vec test-log) ["pair enter" "a=1 b=2" "pair exit"]))
(print "✓ Destructuring binding works\n")

; ============================================================================
; 6. Nested with statements
; ============================================================================

(print "--- 6. Nested with statements ---")

(set! test-log (list))
(with [outer (cm1)]
  (log (+ "outer: " outer))
  (with [inner (cm2)]
    (log (+ "inner: " inner))))

(print "Log:" test-log)
(assert (= (vec test-log) ["cm1 enter" "outer: r1" "cm2 enter" "inner: r2" "cm2 exit" "cm1 exit"]))
(print "✓ Nested with works\n")

; ============================================================================
; 7. With in let block
; ============================================================================

(print "--- 7. With in let block ---")

(set! test-log (list))
(let [prefix "test"]
  (with [r (simple-cm)]
    (log (+ prefix ": " r))))

(print "Log:" test-log)
(assert (= (vec test-log) ["enter" "test: resource" "exit"]))
(print "✓ With in let works\n")

; ============================================================================
; 8. Exception handling in with
; ============================================================================

(print "--- 8. Exception handling in with ---")

(def cleanup-cm
  ((. contextlib contextmanager)
   (fn ^generator []
     (log "cleanup enter")
     (try
       (yield "cleanup-resource")
       (finally
         (log "cleanup exit"))))))

(set! test-log (list))
(try
  (with [r (cleanup-cm)]
    (log "before error")
    (throw (RuntimeError "test error"))
    (log "after error"))
  (catch RuntimeError e
    (log "caught error")))

(print "Log:" test-log)
(assert (= (vec test-log) ["cleanup enter" "before error" "cleanup exit" "caught error"]))
(print "✓ Exception handling with cleanup works\n")

; ============================================================================
; 9. Real file handling (if available)
; ============================================================================

(print "--- 9. Real file handling ---")

; Create a temp file, write to it, read from it
(let [tmpdir (tempfile.gettempdir)
      tmpfile (+ tmpdir "/spork_test_with.txt")]

  ; Write to file
  (with [f (open tmpfile "w")]
    (.write f "Hello from spork!"))

  ; Read from file
  (with [f (open tmpfile "r")]
    (let [content (.read f)]
      (print "File content:" content)
      (assert (= content "Hello from spork!"))))

  ; Clean up
  (os.remove tmpfile))

(print "✓ Real file handling works\n")

; ============================================================================
; 10. Dict destructuring in with
; ============================================================================

(print "--- 10. Dict destructuring in with ---")

(def dict-cm
  ((. contextlib contextmanager)
   (fn ^generator []
     (log "dict enter")
     (yield {:name "Alice" :age 30})
     (log "dict exit"))))

(set! test-log (list))
(with [{:keys [name age]} (dict-cm)]
  (log (+ "name=" name " age=" (str age))))

(print "Log:" test-log)
(assert (= (vec test-log) ["dict enter" "name=Alice age=30" "dict exit"]))
(print "✓ Dict destructuring in with works\n")

; ============================================================================
; 11. With as last expression in defn
; ============================================================================

(print "--- 11. With as last expression in defn ---")

(defn process-with-cm []
  (with [r (simple-cm)]
    42))

(set! test-log (list))
(def result11 (process-with-cm))
(print "Result:" result11)
(assert (= result11 42))
(assert (= (vec test-log) ["enter" "exit"]))
(print "✓ With as last expression in defn works\n")

; ============================================================================
; 12. Mixed binding and no-binding
; ============================================================================

(print "--- 12. Mixed binding and no-binding ---")

(set! test-log (list))
(with [r (cm1)
       (no-bind-cm)]
  (log (+ "got: " r)))

(print "Log:" test-log)
(assert (= (vec test-log) ["cm1 enter" "no-bind enter" "got: r1" "no-bind exit" "cm1 exit"]))
(print "✓ Mixed binding and no-binding works\n")

; ============================================================================
; Summary
; ============================================================================

(print "=== All with statement tests passed! ===")
(print "✓ Basic with statement")
(print "✓ With without binding")
(print "✓ Multiple context managers")
(print "✓ With returning value from function")
(print "✓ Destructuring binding (vector)")
(print "✓ Nested with statements")
(print "✓ With in let block")
(print "✓ Exception handling in with")
(print "✓ Real file handling")
(print "✓ Dict destructuring in with")
(print "✓ With as last expression in defn")
(print "✓ Mixed binding and no-binding")

; ============================================================================
; 13. Test yield (used by context managers above)
; ============================================================================

(print "\n--- 13. Testing yield ---")

(defn ^generator simple-generator []
  (yield 1)
  (yield 2)
  (yield 3))

(def gen-result (list (simple-generator)))
(print "simple-generator result:" gen-result)
(assert (= (vec gen-result) [1 2 3]))
(print "✓ Basic yield works")

; Test yield with expression value
(defn ^generator double-generator [items]
  (for [x items]
    (yield (* x 2))))

(def double-result (list (double-generator [1 2 3 4])))
(print "double-generator [1 2 3 4]:" double-result)
(assert (= (vec double-result) [2 4 6 8]))
(print "✓ Yield in for loop works")

; Test yield as expression (returns sent value)
(defn ^generator echo-generator []
  (let [received (yield "ready")]
    (yield (+ "got: " (str received)))))

(let [gen (echo-generator)]
  (def first-val (next gen))
  (print "First yield:" first-val)
  (assert (= first-val "ready"))
  (def second-val (.send gen "hello"))
  (print "After send:" second-val)
  (assert (= second-val "got: hello")))
(print "✓ Yield as expression works")

; ============================================================================
; 14. Test yield-from
; ============================================================================

(print "\n--- 14. Testing yield-from ---")

(defn ^generator sub-generator []
  (yield "a")
  (yield "b")
  (yield "c"))

(defn ^generator delegating-generator []
  (yield "start")
  (yield-from (sub-generator))
  (yield "end"))

(def delegate-result (list (delegating-generator)))
(print "delegating-generator result:" delegate-result)
(assert (= (vec delegate-result) ["start" "a" "b" "c" "end"]))
(print "✓ Basic yield-from works")

; Test yield-from with built-in iterables
(defn ^generator yield-range [n]
  (yield-from (range n)))

(def range-result (list (yield-range 5)))
(print "yield-range 5:" range-result)
(assert (= (vec range-result) [0 1 2 3 4]))
(print "✓ Yield-from with range works")

; Test nested yield-from
(defn ^generator nested-delegate []
  (yield-from [1 2])
  (yield-from [3 4])
  (yield-from [5]))

(def nested-result (list (nested-delegate)))
(print "nested-delegate result:" nested-result)
(assert (= (vec nested-result) [1 2 3 4 5]))
(print "✓ Multiple yield-from works")

; Test yield-from in expression context
(defn ^generator gen-with-result []
  (let [total (yield-from [1 2 3])]
    (yield (+ "done: " (str total)))))

; Note: yield-from returns the value from StopIteration, which is None for lists
(def expr-result (list (gen-with-result)))
(print "gen-with-result:" expr-result)
(assert (= (vec expr-result) [1 2 3 "done: None"]))
(print "✓ Yield-from as expression works")

(print "\n=== All yield tests passed! ===")
(print "✓ Basic yield")
(print "✓ Yield in loops")
(print "✓ Yield as expression")
(print "✓ Basic yield-from")
(print "✓ Yield-from with iterables")
(print "✓ Multiple yield-from")
(print "✓ Yield-from as expression")
